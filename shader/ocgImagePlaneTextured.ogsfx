#version 430

// World-view-projection transformation.
uniform mat4 gWVPXf : WorldViewProjection;

// The solid color uniform, its default value and several extra
// parameters
uniform vec4 gSolidColor : DIFFUSE = {1, 1, 1, 1};

// Matrix used to multiply colors, to perform color (linear)
// grading/correction.
uniform float4x4 gImageColorMatrix < string UIWidget = "None"; >;

// The main image texture displaying RGBA values to the user.
uniform texture2D gImageTexture
<
    string ResourceName = "";
    string ResourceType = "2D";
>;

uniform sampler2D gImageTextureSampler = sampler_state
{
    Texture = <gImageTexture>;
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
    TEXTURE_WRAP_R = CLAMP_TO_EDGE;
};

// The 3D LUT texture to transform the texture colours.
uniform bool g3dLutEnable = false;
uniform int g3dLutEdgeSize = 0;
uniform texture3D g3dLutTexture
<
    string ResourceName = "";
    string ResourceType = "3D";
>;

uniform sampler3D g3dLutTextureSampler = sampler_state
{
    Texture = <g3dLutTexture>;
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
    TEXTURE_WRAP_R = CLAMP_TO_EDGE;
};

// The 3D LUT texture to transform the texture colours.
uniform bool gColorOpsLutEnable = false;
uniform int gColorOpsLutEdgeSize = 0;
uniform texture3D gColorOps3dLutTexture
<
    string ResourceName = "";
    string ResourceType = "3D";
>;

uniform sampler3D gColorOps3dLutTextureSampler = sampler_state
{
    Texture = <gColorOps3dLutTexture>;
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
    TEXTURE_WRAP_R = CLAMP_TO_EDGE;
};

uniform texture1D gColorOps1dLutTexture
<
    string ResourceName = "";
    string ResourceType = "1D";
>;

uniform sampler1D gColorOps1dLutTextureSampler = sampler_state
{
    Texture = <gColorOps1dLutTexture>;
    TEXTURE_MIN_FILTER = NEAREST;
    TEXTURE_MAG_FILTER = NEAREST;
    TEXTURE_WRAP_S = CLAMP_TO_EDGE;
    TEXTURE_WRAP_T = CLAMP_TO_EDGE;
    TEXTURE_WRAP_R = CLAMP_TO_EDGE;
};

// Transforms to be applied to the vertices in various ways.
uniform float4x4 gRescaleTransform < string UIWidget = "None"; >;
uniform float4x4 gGeometryTransform < string UIWidget = "None"; >;

attribute vs_input
{
    vec3 in_position : POSITION;
    vec2 in_texcoord : TEXCOORD0;
};

attribute vs_to_ps
{
    vec2 texcoord;
};

attribute ps_output
{
    vec4 out_color : COLOR0;
}

GLSLShader VS
{
    void main()
    {
        gl_Position = gWVPXf * gGeometryTransform * gRescaleTransform * vec4(in_position, 1);
        vsOut.texcoord.x = in_texcoord.x;
        vsOut.texcoord.y = in_texcoord.y;
    }
}

GLSLShader PS
{
    void main()
    {
        vec4 tex_color = texture2D(gImageTextureSampler, psIn.texcoord);

        // Color Space
        if (g3dLutEnable) {
            float m = float(g3dLutEdgeSize-1) / float(g3dLutEdgeSize);
            float b = 1.0 / (2.0 * float(g3dLutEdgeSize));
            tex_color = vec4(
                texture3D(g3dLutTextureSampler, m * tex_color.rgb + b).rgb,
                tex_color.a);
        }

        // Color Ops
        if (gColorOpsLutEnable) {
            float m = float(gColorOpsLutEdgeSize-1) / float(gColorOpsLutEdgeSize);
            float b = 1.0 / (2.0 * float(gColorOpsLutEdgeSize));

            float coord_1d = m * tex_color.a + b;
            float alpha =
                texture1D(gColorOps1dLutTextureSampler,
                          coord_1d).r;

            vec3 coord_3d = m * tex_color.rgb + b;
            tex_color = vec4(
                texture3D(gColorOps3dLutTextureSampler,
                          m * tex_color.rgb + b).rgb,
                alpha);
        }

        out_color = gSolidColor * gImageColorMatrix * tex_color;
    }
}

technique Main
{
    pass p0
    {
        VertexShader (in vs_input, out vs_to_ps vsOut) = VS;
        PixelShader (in vs_to_ps psIn, out ps_output) = PS;
    }
}
